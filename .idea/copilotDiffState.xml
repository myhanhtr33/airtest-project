<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/tests/testest.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/testest.py" />
              <option name="originalContent" value="from Hierarchy.PopupCampaignSelectLv import PopupCampaignSelectLv&#10;from Hierarchy.Tutorial_UI import *&#10;from Hierarchy.UI_ingame import *&#10;from Hierarchy.HOME_Element import *&#10;import os&#10;from logger_config import get_logger&#10;from utils.helper_functions import wait_for_element&#10;from utils.test_level_helper import *&#10;from utils.get_resource_amount import *&#10;from airtest.core.api import swipe, sleep, wait, keyevent, Template&#10;from airtest.core.error import TargetNotFoundError&#10;&#10;current_dir=os.path.dirname(os.path.abspath(__file__))&#10;img_path= os.path.join(os.path.dirname(current_dir),&quot;image&quot;,&quot;Plane1_bata.png&quot;)&#10;bata_img = Template(img_path)&#10;&#10;img_path= os.path.join(os.path.dirname(current_dir),&quot;image&quot;,&quot;Handtut.png&quot;)&#10;hand_tut_img = Template(img_path)&#10;img_path= os.path.join(os.path.dirname(current_dir),&quot;image&quot;,&quot;tutLv_noti_frame.png&quot;)&#10;ingame_noti_img = Template(img_path)&#10;&#10;&#10;def notfound():&#10;    print(&quot;No target found&quot;)&#10;    return None&#10;&#10;class TestIngameeee:&#10;    def setup(self):&#10;        pass&#10;    def test1111(self, poco):&#10;        logger = get_logger()&#10;        ui_ingame = UI_Ingame(poco)&#10;        btn_active_skill_tut=poco(&quot;fadeCooldownActiveSkills&quot;)&#10;        tutLv1_P1_1 = None&#10;        tutLv1_P1_2 = None&#10;        is_complete_tutLv1_P1 = None&#10;        is_complete_tutLv1_P2 = None&#10;        if wait_for_element(ui_ingame.root, timeout=5):&#10;            bata_pos = wait(bata_img, timeout=6, intervalfunc=notfound())&#10;            btn_skill_pos = ui_ingame.btn_plane_skill.get_position() if ui_ingame.btn_plane_skill.exists() else None&#10;            tmp = UITop(poco).collected_gold&#10;            gold= 0&#10;            if bata_pos and btn_skill_pos:&#10;                start_pos = ((bata_pos[0] - btn_skill_pos[0]) / 2 + btn_skill_pos[0], bata_pos[1])&#10;                end_pos = (bata_pos[0] + (bata_pos[0] - start_pos[0]), bata_pos[1])&#10;&#10;                ingameUI = UI_Ingame(poco)&#10;                btn_node = ingameUI.btn_plane_skill&#10;                btn = btn_node if btn_node.exists() else None&#10;                btn_gem_revival_popup_node= RevivalPopup(poco).btn_gem&#10;                btn_gem_revival_popup= btn_gem_revival_popup_node if btn_gem_revival_popup_node.exists() else None&#10;&#10;                first_move = False&#10;                while btn:&#10;                    if btn_gem_revival_popup:&#10;                        if get_single_resource_amount(poco, &quot;gem&quot;)&lt;50:&#10;                            self.poco.invoke(&quot;add_gem&quot;, amount=50)&#10;                            # logger.info(&quot;Not enough gems for revival, invoking add_gem&quot;)&#10;                        sleep(1)&#10;                        # logger.info(&quot;Revival popup detected, clicking revive button&quot;)&#10;                        btn_gem_revival_popup.click(sleep_interval=1)&#10;                        sleep(2)&#10;                        continue&#10;                    if not first_move:&#10;                        for i in range(30):&#10;                            keyevent(&quot;P&quot;)&#10;                        swipe(bata_pos, start_pos)  # move to start position&#10;                        first_move = True&#10;                    if not tutLv1_P1_1:&#10;                        try:&#10;                            tutLv1_P1_1 = wait(hand_tut_img, timeout=6, intervalfunc=notfound())&#10;                            tutLv1_P1_2 = wait(ingame_noti_img, timeout=6, intervalfunc=notfound())&#10;                            btn_active_skill_tut.click(sleep_interval=1)&#10;                            is_complete_tutLv1_P1 = tutLv1_P1_1 is not None and tutLv1_P1_2 is not None&#10;                            print(&#10;                                f&quot;::::::::::::::::tutLv1_1_1: {tutLv1_P1_1}, tutLv1_1_2: {tutLv1_P1_2}, is_complete_tutLv1_P1: {is_complete_tutLv1_P1}&quot;)&#10;                        except TargetNotFoundError:&#10;                            # logger.warning(&quot;Hand tutorial image or ingame notification frame not found, continuing...&quot;)&#10;                            is_complete_tutLv1_P1 = None&#10;                    keyevent(&quot;C&quot;)&#10;                    swipe(start_pos, end_pos, duration=2)&#10;                    tmp = UITop(poco).collected_gold&#10;                    gold= max(gold,tmp) if tmp is not None else gold&#10;                    print(f&quot;gold_text2: {gold}&quot;)&#10;                    swipe(end_pos, start_pos, duration=2)&#10;                    tmp = UITop(poco).collected_gold&#10;                    gold= max(gold,tmp) if tmp is not None else gold&#10;                    print(f&quot;gold_text3: {gold}&quot;)&#10;                    keyevent(&quot;C&quot;)&#10;                    sleep(1)&#10;                    tmp = UITop(poco).collected_gold&#10;                    gold= max(gold,tmp) if tmp is not None else gold&#10;                    print(f&quot;gold_text4: {gold}&quot;)&#10;                    btn = ingameUI.btn_plane_skill if ingameUI.btn_plane_skill.exists() else None&#10;            print(f&quot;collected_gold_text: {gold}&quot;)&#10;            max_attempts = 5&#10;            for attempt in range(max_attempts):&#10;                popup_lose = PopupGameLose(poco)&#10;                popup_win = PopupGameWin(poco)&#10;                if popup_lose.root.exists():&#10;                    # logger.info(&quot;Game lost, retrying...&quot;)&#10;                    # popup_lose.btn_retry.click(sleep_interval=3)&#10;                    # # Retry logic can be added here if needed&#10;                    break&#10;                elif popup_win.root.exists():&#10;                    # logger.info(&quot;Game won!&quot;)&#10;                    sleep(2)&#10;                    try:&#10;                        tutLv1_P2 = wait(hand_tut_img, timeout=15, intervalfunc=notfound())&#10;                        if tutLv1_P2:&#10;                            btn_back = popup_win.btn_back&#10;                            if btn_back:&#10;                                btn_back.click(sleep_interval=1)&#10;                                is_complete_tutLv1_P2 = True&#10;                                print(&quot;Back button clicked after win popup&quot;)&#10;                            # else:&#10;                            #     logger.warning(&quot;Back button not found after win popup&quot;)&#10;                        # else:&#10;                        #     logger.warning(&quot;Hand tutorial image not found after win popup&quot;)&#10;                    except TargetNotFoundError:&#10;                        # logger.warning(&quot;Hand tutorial image not found after win popup&quot;)&#10;                        is_complete_tutLv1_P2 = None&#10;                    break&#10;                attempt += 1&#10;                sleep(2)&#10;                # Raise error if we run out of attempts and neither win nor lose popup appears&#10;                if attempt &gt;= max_attempts - 1:&#10;                    raise AssertionError(&quot;Game didn't reach a conclusion (win or lose) after maximum attempts&quot;)&#10;        is_complete_tutLv1= is_complete_tutLv1_P1 and is_complete_tutLv1_P2&#10;        print(f&quot;complete whole tutorial: {is_complete_tutLv1}&quot;)&#10;&#10;    def test2222(self, poco):&#10;        popup= PopupCampaignSelectLv(poco)&#10;        normal_levels=popup.list_level_normal&#10;        # for level in normal_levels:&#10;        #     lv= level.index&#10;        #     list_star= level.list_star&#10;        #     star1_sprite= level.star1_sprite&#10;        #     star2_sprite= level.star2_sprite&#10;        #     star3_sprite= level.star3_sprite&#10;        #     # Only attempt to index when list_star exists and the sprite is a non-empty string&#10;        #     if list_star:&#10;        #         s1 = star1_sprite[-1] if isinstance(star1_sprite, str) and star1_sprite else None&#10;        #         s2 = star2_sprite[-1] if isinstance(star2_sprite, str) and star2_sprite else None&#10;        #         s3 = star3_sprite[-1] if isinstance(star3_sprite, str) and star3_sprite else None&#10;        #         print(f&quot;lv:{lv}  {(s1, s2, s3)}&quot;)&#10;        #     else:&#10;        #         print(f&quot;lv:{lv}  NOne&quot;)&#10;&#10;        # level=7&#10;        # is_max=is_max_unlocked_level(level, normal_levels)&#10;        # print(f&quot;Is {level} max level: {is_max}&quot;)&#10;&#10;        amount, name = get_single_card_amount_by_sprite(poco, &quot;card_A0&quot;)&#10;        print(f&quot;::::::::::: amount: {amount}, name: {name}&quot;)&#10;&#10;    def test_tut(self, poco):&#10;        from airtest.core.api import find_all&#10;        logger=get_logger(&quot;TestTUT&quot;)&#10;        campaign_select_lv = PopupCampaignSelectLv(poco)&#10;        normal_levels = campaign_select_lv.list_level_normal&#10;&#10;        # Get screen dimensions for coordinate conversion using Poco&#10;        screen_width, screen_height = poco.get_screen_size()&#10;&#10;        for lv in normal_levels:&#10;            # has_mini_chest = has_valid_mini_chest(lv, poco, logger=logger)&#10;            # if has_mini_chest:&#10;            #     print(f&quot;Level {lv.index}({lv.root.get_position()}) has a valid mini chest{has_mini_chest}.&quot;)&#10;            # else:&#10;            #     print(f&quot;Level {lv.index} does not have a valid mini chest.&quot;)&#10;            if lv.index==4:&#10;                mini_chest_position= has_valid_mini_chest(lv, poco, logger=logger)&#10;                if mini_chest_position:&#10;                    print(f&quot;Level {lv.index}({lv.root.get_position()}) has a valid mini chest{mini_chest_position}.&quot;)&#10;                    touch(mini_chest_position)&#10;&#10;&#10;" />
              <option name="updatedContent" value="from Hierarchy.PopupCampaignSelectLv import PopupCampaignSelectLv&#10;from Hierarchy.Tutorial_UI import *&#10;from Hierarchy.UI_ingame import *&#10;from Hierarchy.HOME_Element import *&#10;import os&#10;from logger_config import get_logger&#10;from utils.helper_functions import wait_for_element&#10;from utils.test_level_helper import *&#10;from utils.get_resource_amount import *&#10;from airtest.core.api import swipe, sleep, wait, keyevent, Template&#10;from airtest.core.error import TargetNotFoundError&#10;&#10;current_dir=os.path.dirname(os.path.abspath(__file__))&#10;img_path= os.path.join(os.path.dirname(current_dir),&quot;image&quot;,&quot;Plane1_bata.png&quot;)&#10;bata_img = Template(img_path)&#10;&#10;img_path= os.path.join(os.path.dirname(current_dir),&quot;image&quot;,&quot;Handtut.png&quot;)&#10;hand_tut_img = Template(img_path)&#10;img_path= os.path.join(os.path.dirname(current_dir),&quot;image&quot;,&quot;tutLv_noti_frame.png&quot;)&#10;ingame_noti_img = Template(img_path)&#10;&#10;&#10;def notfound():&#10;    print(&quot;No target found&quot;)&#10;    return None&#10;&#10;class TestIngameeee:&#10;    def setup(self):&#10;        pass&#10;    def test1111(self, poco):&#10;        logger = get_logger()&#10;        ui_ingame = UI_Ingame(poco)&#10;        btn_active_skill_tut=poco(&quot;fadeCooldownActiveSkills&quot;)&#10;        tutLv1_P1_1 = None&#10;        tutLv1_P1_2 = None&#10;        is_complete_tutLv1_P1 = None&#10;        is_complete_tutLv1_P2 = None&#10;        if wait_for_element(ui_ingame.root, timeout=5):&#10;            bata_pos = wait(bata_img, timeout=6, intervalfunc=notfound())&#10;            btn_skill_pos = ui_ingame.btn_plane_skill.get_position() if ui_ingame.btn_plane_skill.exists() else None&#10;            tmp = UITop(poco).collected_gold&#10;            gold= 0&#10;            if bata_pos and btn_skill_pos:&#10;                start_pos = ((bata_pos[0] - btn_skill_pos[0]) / 2 + btn_skill_pos[0], bata_pos[1])&#10;                end_pos = (bata_pos[0] + (bata_pos[0] - start_pos[0]), bata_pos[1])&#10;&#10;                ingameUI = UI_Ingame(poco)&#10;                btn_node = ingameUI.btn_plane_skill&#10;                btn = btn_node if btn_node.exists() else None&#10;                btn_gem_revival_popup_node= RevivalPopup(poco).btn_gem&#10;                btn_gem_revival_popup= btn_gem_revival_popup_node if btn_gem_revival_popup_node.exists() else None&#10;&#10;                first_move = False&#10;                while btn:&#10;                    if btn_gem_revival_popup:&#10;                        if get_single_resource_amount(poco, &quot;gem&quot;)&lt;50:&#10;                            self.poco.invoke(&quot;add_gem&quot;, amount=50)&#10;                            # logger.info(&quot;Not enough gems for revival, invoking add_gem&quot;)&#10;                        sleep(1)&#10;                        # logger.info(&quot;Revival popup detected, clicking revive button&quot;)&#10;                        btn_gem_revival_popup.click(sleep_interval=1)&#10;                        sleep(2)&#10;                        continue&#10;                    if not first_move:&#10;                        for i in range(30):&#10;                            keyevent(&quot;P&quot;)&#10;                        swipe(bata_pos, start_pos)  # move to start position&#10;                        first_move = True&#10;                    if not tutLv1_P1_1:&#10;                        try:&#10;                            tutLv1_P1_1 = wait(hand_tut_img, timeout=6, intervalfunc=notfound())&#10;                            tutLv1_P1_2 = wait(ingame_noti_img, timeout=6, intervalfunc=notfound())&#10;                            btn_active_skill_tut.click(sleep_interval=1)&#10;                            is_complete_tutLv1_P1 = tutLv1_P1_1 is not None and tutLv1_P1_2 is not None&#10;                            print(&#10;                                f&quot;::::::::::::::::tutLv1_1_1: {tutLv1_P1_1}, tutLv1_1_2: {tutLv1_P1_2}, is_complete_tutLv1_P1: {is_complete_tutLv1_P1}&quot;)&#10;                        except TargetNotFoundError:&#10;                            # logger.warning(&quot;Hand tutorial image or ingame notification frame not found, continuing...&quot;)&#10;                            is_complete_tutLv1_P1 = None&#10;                    keyevent(&quot;C&quot;)&#10;                    swipe(start_pos, end_pos, duration=2)&#10;                    tmp = UITop(poco).collected_gold&#10;                    gold= max(gold,tmp) if tmp is not None else gold&#10;                    print(f&quot;gold_text2: {gold}&quot;)&#10;                    swipe(end_pos, start_pos, duration=2)&#10;                    tmp = UITop(poco).collected_gold&#10;                    gold= max(gold,tmp) if tmp is not None else gold&#10;                    print(f&quot;gold_text3: {gold}&quot;)&#10;                    keyevent(&quot;C&quot;)&#10;                    sleep(1)&#10;                    tmp = UITop(poco).collected_gold&#10;                    gold= max(gold,tmp) if tmp is not None else gold&#10;                    print(f&quot;gold_text4: {gold}&quot;)&#10;                    btn = ingameUI.btn_plane_skill if ingameUI.btn_plane_skill.exists() else None&#10;            print(f&quot;collected_gold_text: {gold}&quot;)&#10;            max_attempts = 5&#10;            for attempt in range(max_attempts):&#10;                popup_lose = PopupGameLose(poco)&#10;                popup_win = PopupGameWin(poco)&#10;                if popup_lose.root.exists():&#10;                    # logger.info(&quot;Game lost, retrying...&quot;)&#10;                    # popup_lose.btn_retry.click(sleep_interval=3)&#10;                    # # Retry logic can be added here if needed&#10;                    break&#10;                elif popup_win.root.exists():&#10;                    # logger.info(&quot;Game won!&quot;)&#10;                    sleep(2)&#10;                    try:&#10;                        tutLv1_P2 = wait(hand_tut_img, timeout=15, intervalfunc=notfound())&#10;                        if tutLv1_P2:&#10;                            btn_back = popup_win.btn_back&#10;                            if btn_back:&#10;                                btn_back.click(sleep_interval=1)&#10;                                is_complete_tutLv1_P2 = True&#10;                                print(&quot;Back button clicked after win popup&quot;)&#10;                            # else:&#10;                            #     logger.warning(&quot;Back button not found after win popup&quot;)&#10;                        # else:&#10;                        #     logger.warning(&quot;Hand tutorial image not found after win popup&quot;)&#10;                    except TargetNotFoundError:&#10;                        # logger.warning(&quot;Hand tutorial image not found after win popup&quot;)&#10;                        is_complete_tutLv1_P2 = None&#10;                    break&#10;                attempt += 1&#10;                sleep(2)&#10;                # Raise error if we run out of attempts and neither win nor lose popup appears&#10;                if attempt &gt;= max_attempts - 1:&#10;                    raise AssertionError(&quot;Game didn't reach a conclusion (win or lose) after maximum attempts&quot;)&#10;        is_complete_tutLv1= is_complete_tutLv1_P1 and is_complete_tutLv1_P2&#10;        print(f&quot;complete whole tutorial: {is_complete_tutLv1}&quot;)&#10;&#10;    def test2222(self, poco):&#10;        popup= PopupCampaignSelectLv(poco)&#10;        normal_levels=popup.list_level_normal&#10;        # for level in normal_levels:&#10;        #     lv= level.index&#10;        #     list_star= level.list_star&#10;        #     star1_sprite= level.star1_sprite&#10;        #     star2_sprite= level.star2_sprite&#10;        #     star3_sprite= level.star3_sprite&#10;        #     # Only attempt to index when list_star exists and the sprite is a non-empty string&#10;        #     if list_star:&#10;        #         s1 = star1_sprite[-1] if isinstance(star1_sprite, str) and star1_sprite else None&#10;        #         s2 = star2_sprite[-1] if isinstance(star2_sprite, str) and star2_sprite else None&#10;        #         s3 = star3_sprite[-1] if isinstance(star3_sprite, str) and star3_sprite else None&#10;        #         print(f&quot;lv:{lv}  {(s1, s2, s3)}&quot;)&#10;        #     else:&#10;        #         print(f&quot;lv:{lv}  NOne&quot;)&#10;&#10;        # level=7&#10;        # is_max=is_max_unlocked_level(level, normal_levels)&#10;        # print(f&quot;Is {level} max level: {is_max}&quot;)&#10;&#10;        amount, name = get_single_card_amount_by_sprite(poco, &quot;card_A0&quot;)&#10;        print(f&quot;::::::::::: amount: {amount}, name: {name}&quot;)&#10;&#10;    def test_tut(self, poco):&#10;        from airtest.core.api import find_all&#10;        logger=get_logger(&quot;TestTUT&quot;)&#10;        campaign_select_lv = PopupCampaignSelectLv(poco)&#10;        normal_levels = campaign_select_lv.list_level_normal&#10;&#10;        # Get screen dimensions for coordinate conversion using Poco&#10;        screen_width, screen_height = poco.get_screen_size()&#10;&#10;        for lv in normal_levels:&#10;            # has_mini_chest = has_valid_mini_chest(lv, poco, logger=logger)&#10;            # if has_mini_chest:&#10;            #     print(f&quot;Level {lv.index}({lv.root.get_position()}) has a valid mini chest{has_mini_chest}.&quot;)&#10;            # else:&#10;            #     print(f&quot;Level {lv.index} does not have a valid mini chest.&quot;)&#10;            if lv.index==4:&#10;                # Compute chest normalized position inline (no helper)&#10;                level_pos_normalized = lv.root.get_position() if lv.root.exists() else None&#10;                mini_chest_position = None&#10;                if level_pos_normalized and lv.mini_chest_image_template:&#10;                    tol_norm = 50.0 / float(screen_height)&#10;                    chest_results = None&#10;                    for _ in range(5):&#10;                        chest_results = find_all(lv.mini_chest_image_template)&#10;                        if chest_results:&#10;                            break&#10;                        sleep(0.5)&#10;                    if chest_results:&#10;                        for chest_result in chest_results:&#10;                            chest_px = chest_result['result']&#10;                            chest_norm = (float(chest_px[0]) / float(screen_width), float(chest_px[1]) / float(screen_height))&#10;                            if chest_norm[0] &gt; level_pos_normalized[0] and abs(chest_norm[1] - level_pos_normalized[1]) &lt; tol_norm:&#10;                                mini_chest_position = chest_norm&#10;                                break&#10;                if mini_chest_position:&#10;                    print(f&quot;Level {lv.index}({lv.root.get_position()}) has a valid mini chest {mini_chest_position}.&quot;)&#10;                    claim_mini_chest_and_validate_rewards(lv, mini_chest_position, poco, logger)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>