<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/tests/Military/test_PopupMilitary.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/Military/test_PopupMilitary.py" />
              <option name="originalContent" value="import concurrent&#10;import time&#10;import pytest&#10;from Hierarchy.PopupMilitary import *&#10;from utils.device_setup import PocoManager&#10;from airtest.core.api import *&#10;from logger_config import get_logger&#10;from utils.helper_functions import check_noti&#10;from utils.get_resource_amount import get_single_resource_amount&#10;from concurrent.futures import ThreadPoolExecutor&#10;from functools import partial&#10;import pdb&#10;len_of_weapon={&#10;    &quot;Aircraft&quot;: 24,&#10;    &quot;Drone&quot;: 24,&#10;    &quot;Wing&quot;:24,&#10;    &quot;Pilot&quot;: 20,&#10;    &quot;Engine&quot;:18&#10;}&#10;&#10;@pytest.fixture(params=[&quot;Air&quot;, &quot;Drone&quot;, &quot;Wing&quot;, &quot;Pilot&quot;, &quot;Engine&quot;])&#10;def name(request) -&gt; Literal[&quot;Air&quot;, &quot;Drone&quot;, &quot;Wing&quot;, &quot;Pilot&quot;, &quot;Engine&quot;]:&#10;    &quot;&quot;&quot;Fixture that provides the name parameter for testing different military point types&quot;&quot;&quot;&#10;    return request.param&#10;@pytest.fixture(scope=&quot;class&quot;)&#10;def military_popup(poco):&#10;    try:&#10;        popup = poco(&quot;PopupMilitaryCareer(Clone)&quot;) if poco(&quot;PopupMilitaryCareer(Clone)&quot;).exists() else None&#10;        return popup&#10;    except Exception as e:&#10;        logger = get_logger()&#10;        logger.warning(f&quot;Failed to access PopupMilitary due to connection error: {e}&quot;)&#10;        return None&#10;&#10;@pytest.fixture(scope=&quot;class&quot;)&#10;def military_back_button(poco):&#10;    try:&#10;        button = poco(&quot;PopupMilitaryCareer(Clone)&quot;).offspring(&quot;B_Back (1)&quot;)&#10;        return button if button.exists() else None&#10;    except Exception as e:&#10;        logger = get_logger()&#10;        logger.warning(f&quot;Failed to access PopupMilitary back button due to connection error: {e}&quot;)&#10;        return None&#10;@pytest.mark.use_to_home(before=True, after=True, logger_name=&quot;PopupMilitary&quot;, back_button=&quot;military_back_button&quot;)&#10;class TestPopupMilitary:&#10;    popup= None&#10;    weapon_point_notices = []&#10;    @pytest.fixture(scope=&quot;function&quot;, autouse=True)&#10;    def setup(cls, poco):&#10;        logger = get_logger(&quot;setup method&quot;)&#10;        logger.info(&quot;Setting up PopupMilitary test environment...&quot;)&#10;        cls.poco = poco&#10;        cls.home_notice = poco(&quot;SubFeatureTopLayer&quot;).offspring(&quot;sNotice&quot;) if poco(&quot;SubFeatureTopLayer&quot;).offspring(&#10;            &quot;sNotice&quot;).exists() else None&#10;        military_home_icon = cls.poco(&quot;SubFeatureTopLayer&quot;).offspring(&quot;Military_Home&quot;)&#10;        assert military_home_icon.exists(), &quot;Military home icon not found&quot;&#10;        military_home_icon.click(sleep_interval=1)&#10;        cls.popup = PopupMilitary(cls.poco)&#10;        with poco.freeze() as fp:&#10;            cls.frozen_popup = PopupMilitary(fp)&#10;        print(f&quot;PopupMilitary instance created: {cls.popup}&quot;)&#10;        print(f&quot;Frozen PopupMilitary instance created: {cls.frozen_popup}&quot;)&#10;        assert cls.popup.root.exists(), &quot;Military popup did not open&quot;&#10;        logger.info(&quot;PopupMilitary test environment setup complete.&quot;)&#10;&#10;    def test_concurrent_exists(self,poco):&#10;        import threading&#10;        import time&#10;        results = {}&#10;        with poco.freeze() as fp:&#10;            freeze_popup = PopupMilitary(fp)&#10;&#10;        def check_back_button():&#10;            nodes = {&#10;                &quot;frozen_btn_back&quot;: freeze_popup.btn_back,&#10;                &quot;frozen_top_panel&quot;: freeze_popup.top_panel,&#10;                &quot;frozen_upgrade_btn&quot;: freeze_popup.upgrade_btn,&#10;                # &quot;btn_back&quot;: self.popup.btn_back,&#10;                # &quot;top_panel&quot;: self.popup.top_panel,&#10;            }&#10;            for k, n in nodes.items():&#10;                try:&#10;                    # presence/visibility from snapshot&#10;                    results[k] = n.exists()  # or n.exists()&#10;                    print(f&quot;Node {k} visibility: {results[k]}&quot;)&#10;                except Exception as e:&#10;                    results[k] = str(e)&#10;                    print(f&quot;Error accessing node {k}: {e}&quot;)&#10;        def check_top_panel():&#10;            nodes = {&#10;                &quot;frozen_rank_badge&quot;: freeze_popup.rank_badge,&#10;                &quot;frozen_upgrade_btn&quot;: freeze_popup.upgrade_btn,&#10;                # &quot;rank_badge&quot;: self.popup.rank_badge,&#10;                # &quot;upgrade_btn&quot;: self.popup.upgrade_btn,&#10;            }&#10;            for k, n in nodes.items():&#10;                try:&#10;                    # presence/visibility from snapshot&#10;                    results[k] = n.exists()  # or n.exists()&#10;                    print(f&quot;Node {k} visibility: {results[k]}&quot;)&#10;                except:&#10;                    results[k] = &quot;error&quot;&#10;                    print(f&quot;Error accessing node {k}&quot;)&#10;        t1 = threading.Thread(target=check_back_button)&#10;        t2 = threading.Thread(target=check_top_panel)&#10;&#10;        start_time = time.time()&#10;        t1.start()&#10;        t2.start()&#10;        t1.join()&#10;        t2.join()&#10;        total = time.time() - start_time&#10;&#10;        print(f&quot;Total time: {total:.3f}s&quot;)&#10;        # print(f&quot;btn_back took: {results['btn_back']}&quot;)&#10;        # print(f&quot;top_panel took: {results['top_panel']}&quot;)&#10;        for key, value in results.items(): print(f&quot;{key}: {value}&quot;)&#10;&#10;    def test_frozen_UI(self,poco):&#10;        logger=get_logger()&#10;        level=self.frozen_popup.get_actual_level()&#10;        print(&quot;::::FROZEN Level:&quot;,level)&#10;        for i, weapon_point in enumerate(self.frozen_popup.weapon_points):&#10;            logger.info(f&quot;Clicking on weapon point {i + 1}: {weapon_point.name}&quot;)&#10;            weapon_point.root.click(sleep_interval=1)&#10;            logger.info(f&quot;Popup Military Get Point opened for {weapon_point.name}&quot;)&#10;            popup_get_point = PopupMilitaryGetPoint(self.poco, weapon_point._name)&#10;            with self.poco.freeze() as fp:&#10;                frozen_popup_get_point = PopupMilitaryGetPoint(fp, weapon_point._name)&#10;            for item in frozen_popup_get_point.items:&#10;                print(&quot;::::FROZEN Item:&quot;, item.root)&#10;                # Scroll to item if needed (using live popup instance)&#10;                popup_get_point.scroll_to_item(item)&#10;                item.root.click(sleep_interval=2)&#10;&#10;    def test_frozen_element_presence(self,poco):&#10;        logger=get_logger()&#10;        with poco.freeze() as fp:&#10;            freeze_popup = PopupMilitary(fp)&#10;        assert freeze_popup.btn_back.exists(), &quot;Back button not found&quot;&#10;        assert freeze_popup.top_panel.exists(), &quot;Top panel not found&quot;&#10;        assert freeze_popup.title.strip() == &quot;Military Career&quot;, &quot;Title text mismatch&quot;&#10;        assert freeze_popup.rank_badge.exists(), &quot;Rank badge not found&quot;&#10;        assert freeze_popup.info_btn.exists(), &quot;Info button not found&quot;&#10;        assert freeze_popup.mid_panel.exists(), &quot;Mid panel not found&quot;&#10;        assert freeze_popup.mid_title.strip() == &quot;All squads get&quot;, &quot;Mid title text mismatch&quot;&#10;        assert len(freeze_popup.passives) == 6, &quot;Expected 6 passives, found {}&quot;.format(len(freeze_popup.passives))&#10;        for i, passive in enumerate(freeze_popup.passives):&#10;            assert passive.root.exists(), f&quot;Passive {i} not found&quot;&#10;            assert passive.sprite.exists(), f&quot;Passive {i} sprite not found&quot;&#10;            assert passive.passive_stat_text != &quot;&quot;, f&quot;Passive {i} stat text is empty&quot;&#10;            assert passive.passive_stat_text.endswith(&quot;%&quot;), f&quot;Passive {i} stat text does not end with '%': {passive.passive_stat_text}&quot;&#10;        assert freeze_popup.bot_panel.exists(), &quot;Bottom panel not found&quot;&#10;        assert freeze_popup.progress_fill.exists(), &quot;Process fill not found&quot;&#10;        assert freeze_popup.progress_info_btn.exists(), &quot;Process info button not found&quot;&#10;        assert freeze_popup.upgrade_btn.exists(), &quot;Upgrade button not found&quot;&#10;        assert len(freeze_popup.weapon_points) == 5, &quot;Expected 5 weapon points, found {}&quot;.format(len(freeze_popup.weapon_points))&#10;        for i, weapon_point in enumerate(freeze_popup.weapon_points):&#10;            assert weapon_point.root.exists(), f&quot;Weapon point {i} not found&quot;&#10;            assert weapon_point.icon.exists(), f&quot;Weapon point {i} icon not found&quot;&#10;            assert weapon_point.name not in [&quot;&quot;, None], f&quot;Weapon point {i} name is empty or None&quot;&#10;            assert int(weapon_point.accumulated_point) &gt;=0, f&quot;Weapon point {i} accumulated point is empty&quot;&#10;            if weapon_point.notice:&#10;                self.weapon_point_notices.append(True)&#10;            else:&#10;                self.weapon_point_notices.append(False)&#10;        assert freeze_popup.level_number_text.strip() != &quot;&quot;, &quot;Level number text is empty&quot;&#10;        assert freeze_popup.level_category_text.strip() != &quot;&quot;, &quot;Level category text is empty&quot;&#10;        assert freeze_popup.progress_text.strip() != &quot;&quot;, &quot;Process text is empty&quot;&#10;        assert freeze_popup.upgrade_price_text.strip() != &quot;&quot;, &quot;Upgrade price text is empty&quot;&#10;        logger.info(&quot;All elements are present and verified successfully.&quot;)&#10;&#10;    @pytest.mark.order(1)&#10;    def test_element_presence(self):&#10;        logger=get_logger()&#10;        assert self.frozen_popup.btn_back.exists(), &quot;Back button not found&quot;&#10;        assert self.frozen_popup.top_panel.exists(), &quot;Top panel not found&quot;&#10;        assert self.frozen_popup.title.strip() == &quot;Military Career&quot;, &quot;Title text mismatch&quot;&#10;        assert self.frozen_popup.rank_badge.exists(), &quot;Rank badge not found&quot;&#10;        assert self.frozen_popup.info_btn.exists(), &quot;Info button not found&quot;&#10;        assert self.frozen_popup.mid_panel.exists(), &quot;Mid panel not found&quot;&#10;        assert self.frozen_popup.mid_title.strip() == &quot;All squads get&quot;, &quot;Mid title text mismatch&quot;&#10;        assert len(self.frozen_popup.passives) == 6, &quot;Expected 6 passives, found {}&quot;.format(len(self.frozen_popup.passives))&#10;        for i, passive in enumerate(self.frozen_popup.passives):&#10;            assert passive.root.exists(), f&quot;Passive {i} not found&quot;&#10;            assert passive.sprite.exists(), f&quot;Passive {i} sprite not found&quot;&#10;            assert passive.passive_stat_text != &quot;&quot;, f&quot;Passive {i} stat text is empty&quot;&#10;            assert passive.passive_stat_text.endswith(&quot;%&quot;), f&quot;Passive {i} stat text does not end with '%': {passive.passive_stat_text}&quot;&#10;        assert self.frozen_popup.bot_panel.exists(), &quot;Bottom panel not found&quot;&#10;        assert self.frozen_popup.progress_fill.exists(), &quot;Process fill not found&quot;&#10;        assert self.frozen_popup.progress_info_btn.exists(), &quot;Process info button not found&quot;&#10;        assert self.frozen_popup.upgrade_btn.exists(), &quot;Upgrade button not found&quot;&#10;        assert len(self.frozen_popup.weapon_points) == 5, &quot;Expected 5 weapon points, found {}&quot;.format(len(self.frozen_popup.weapon_points))&#10;        for i, weapon_point in enumerate(self.frozen_popup.weapon_points):&#10;            assert weapon_point.root.exists(), f&quot;Weapon point {i} not found&quot;&#10;            assert weapon_point.icon.exists(), f&quot;Weapon point {i} icon not found&quot;&#10;            assert weapon_point.name not in [&quot;&quot;, None], f&quot;Weapon point {i} name is empty or None&quot;&#10;            assert int(weapon_point.accumulated_point) &gt;=0, f&quot;Weapon point {i} accumulated point is empty&quot;&#10;            if weapon_point.notice:&#10;                self.weapon_point_notices.append(True)&#10;            else:&#10;                self.weapon_point_notices.append(False)&#10;        assert self.frozen_popup.level_number_text.strip() != &quot;&quot;, &quot;Level number text is empty&quot;&#10;        assert self.frozen_popup.level_category_text.strip() != &quot;&quot;, &quot;Level category text is empty&quot;&#10;        assert self.frozen_popup.progress_text.strip() != &quot;&quot;, &quot;Process text is empty&quot;&#10;        assert self.frozen_popup.upgrade_price_text.strip() != &quot;&quot;, &quot;Upgrade price text is empty&quot;&#10;        logger.info(&quot;All elements are present and verified successfully.&quot;)&#10;    @pytest.mark.order(2)&#10;    def test_valid_rank_category(self):&#10;        logger=get_logger()&#10;        actual_rank=self.frozen_popup.level_category_text&#10;        assert actual_rank in rank_category, f&quot;Invalid rank category: {actual_rank}&quot;&#10;        logger.info(f&quot;rank category '{actual_rank}' is valid.&quot;)&#10;    @pytest.mark.order(3)&#10;    def test_click_info_button(self):&#10;        logger=get_logger()&#10;        self.frozen_popup.info_btn.click(sleep_interval=1)&#10;        popup_info= PopupMilitaryCareerInfo(self.poco)&#10;        assert popup_info.root.exists(), &quot;Popup Military Career Info did not open&quot;&#10;        popup_info.btn_back.click(sleep_interval=1)&#10;        assert not popup_info.root.exists(), &quot;Popup Military Career Info did not close&quot;&#10;        logger.info(&quot;Info button functionality verified successfully.&quot;)&#10;    @pytest.mark.order(4)&#10;    def test_passive_sprite(self):&#10;        logger=get_logger()&#10;        actual_sprites=[&#10;            passive.sprite.attr(&quot;texture&quot;).strip()&#10;            for passive in self.frozen_popup.passives&#10;        ]&#10;        for i, actual_sprite in enumerate(actual_sprites):&#10;            assert actual_sprite == expected_passive_sprites[i], f&quot;Passive {i} sprite mismatch: {actual_sprite} != {expected_passive_sprites[i]}&quot;&#10;        logger.info(&quot;Passive sprite functionality verified successfully.&quot;)&#10;    @pytest.mark.order(5)&#10;    def test_passive_stat(self):&#10;        logger=get_logger()&#10;        actual_stats=[&#10;            passive.passive_stat_text.rstrip(&quot;%&quot;)&#10;            for passive in self.frozen_popup.passives&#10;        ]&#10;        actual_stats=[float(stat) for stat in actual_stats]&#10;        actual_lv=self.frozen_popup.get_actual_level()&#10;        expected_stats= self.frozen_popup.get_expected_stats_by_lv(actual_lv)&#10;        assert actual_stats == expected_stats, f&quot;Stats mismatch - Actual: {actual_stats}, Expected: {expected_stats}&quot;&#10;        logger.info(&quot;Passive stats  verified successfully.&quot;)&#10;    @pytest.mark.order(6)&#10;    def test_click_progress_info_button(self):&#10;        logger=get_logger()&#10;        self.frozen_popup.progress_info_btn.click(sleep_interval=1.5)&#10;        panel=self.poco(&quot;PanelTooltipInfo&quot;).offspring(&quot;lDes&quot;)&#10;        panel_text=panel.get_text().strip()&#10;        assert panel_text==&quot;Career Point&quot;, &quot;Progress info button did not show correct text&quot;&#10;        self.frozen_popup.progress_info_btn.click(sleep_interval=1.5)&#10;        panel=self.poco(&quot;PanelTooltipInfo&quot;).offspring(&quot;lDes&quot;)&#10;        assert not panel.exists(), &quot;Panel did not close after clicking again&quot;&#10;    @pytest.mark.order(7)&#10;    def test_valid_progress_point_and_price(self):&#10;        logger=get_logger()&#10;        actual_current_point,actual_required_point= self.frozen_popup.get_progress_points()&#10;        assert actual_current_point &gt;= 0, f&quot;Current point is negative: {actual_current_point}&quot;&#10;        expected_required_point= PopupMilitary.get_expected_required_point(self.frozen_popup.get_actual_level()+1)&#10;        assert actual_required_point == expected_required_point, f&quot;Required point mismatch: {actual_required_point} != {expected_required_point}&quot;&#10;        actual_price=int(self.frozen_popup.upgrade_price_text.replace(&quot;,&quot;,&quot;&quot;))&#10;        assert actual_price==PopupMilitary.get_expected_upgrade_price(self.frozen_popup.get_actual_level()+1), f&quot;Upgrade price mismatch: {actual_price} != {PopupMilitary.get_expected_upgrade_price(self.frozen_popup.get_actual_level()+1)}&quot;&#10;        logger.info(f&quot;Progress points and upgrade price verified successfully: Current Point: {actual_current_point}, Required Point: {actual_required_point}, Upgrade Price: {actual_price}&quot;)&#10;&#10;    @pytest.mark.order(8)&#10;    def test_deactivate_upgrade_btn(self):&#10;        logger=get_logger()&#10;        current_point,required_point= self.frozen_popup.get_progress_points()&#10;        upgrade_price=self.frozen_popup.upgrade_price_text&#10;        initial_values = (current_point, required_point, upgrade_price)&#10;        if current_point&gt;=required_point:&#10;            logger.info(&quot;active upgrade button&quot;)&#10;            return&#10;        assert not self.frozen_popup.upgrade_btn_notice, &quot;Upgrade button notice should not be active&quot;&#10;        assert self.frozen_popup.upgrade_btn_sprite==&quot;UI5_Bottom_btn_9sl_Grey&quot;, f&quot;Upgrade button sprite should be greyed out, found {self.popup.upgrade_btn_sprite}&quot;&#10;        self.frozen_popup.upgrade_btn.click()&#10;        check_noti(self.poco,&quot;Not enough currency&quot;)&#10;        #verify state after click&#10;        assert not self.popup.upgrade_btn_notice, &quot;Upgrade button notice should not be active&quot;&#10;        assert self.popup.upgrade_btn_sprite == &quot;UI5_Bottom_btn_9sl_Grey&quot;, f&quot;Upgrade button sprite should be greyed out, found {self.popup.upgrade_btn_sprite}&quot;&#10;        refreshed_values = (&#10;            *self.popup.get_progress_points(),&#10;            self.popup.upgrade_price_text&#10;        )&#10;        assert initial_values == refreshed_values, (&#10;            f&quot;Upgrade button click should not change points or price, but got {refreshed_values}&quot;&#10;        )&#10;        print(f&quot;homenotice:{self.home_notice}&quot;)&#10;        logger.info(&quot;Upgrade button deactivated successfully when points are insufficient.&quot;)&#10;    @pytest.mark.order(9)&#10;    def test_active_upgrade_btn(self):&#10;        logger=get_logger()&#10;        current_point,required_point= self.frozen_popup.get_progress_points()&#10;        upgrade_price=int(self.frozen_popup.upgrade_price_text.replace(&quot;,&quot;,&quot;&quot;))&#10;        initial_values = (self.frozen_popup.get_actual_level(),current_point, required_point, upgrade_price)&#10;        if current_point&lt;required_point:&#10;            logger.info(&quot;deactive upgrade button&quot;)&#10;            return&#10;        if upgrade_price&gt;get_single_resource_amount(self.poco, &quot;gold&quot;):&#10;            self.frozen_popup.upgrade_btn.click()&#10;            popup_notice= self.poco(&quot;PopupNotice(Clone)&quot;) if self.poco(&quot;PopupNotice(Clone)&quot;).exists() else None&#10;            assert popup_notice, &quot;Popup Notice did not appear&quot;&#10;            popup_notice.offspring(&quot;bClose&quot;).click(sleep_interval=1)&#10;            popup_notice= self.poco(&quot;PopupNotice(Clone)&quot;) if self.poco(&quot;PopupNotice(Clone)&quot;).exists() else None&#10;            assert not popup_notice, &quot;Popup Notice did not close after clicking close button&quot;&#10;            self.poco.invoke(&quot;add_gold&quot;, amount=upgrade_price)&#10;            time.sleep(3)&#10;            assert upgrade_price&lt;get_single_resource_amount(self.poco, &quot;gold&quot;), f&quot;Upgrade price {upgrade_price} is greater than gem amount {get_single_resource_amount(self.poco, 'gem')}&quot;&#10;        assert self.popup.upgrade_btn_notice, &quot;Upgrade button notice should be active&quot;&#10;        assert self.popup.upgrade_btn_sprite==&quot;UI5_Bottom_btn_9sl_Blue&quot;, f&quot;Upgrade button sprite should be orange, found {self.popup.upgrade_btn_sprite}&quot;&#10;        self.frozen_popup.upgrade_btn.click(sleep_interval=7)&#10;        #verify state after click&#10;        expected_level= initial_values[0]+1&#10;        expected_current_point= initial_values[1]- initial_values[2]&#10;        expected_required_point = PopupMilitary.get_expected_required_point(expected_level + 1)&#10;        expected_rank_category=rank_category[expected_level//10]&#10;        expected_level_number= expected_level % 10&#10;        expected_upgrade_price= PopupMilitary.get_expected_upgrade_price(expected_level+1)&#10;        with self.poco.freeze() as fp:&#10;            self.frozen_popup = PopupMilitary(fp)&#10;        expected_passive_stats= self.frozen_popup.get_expected_stats_by_lv(expected_level)&#10;        assert self.frozen_popup.get_actual_level() == expected_level, f&quot;Level did not upgrade to {expected_level}&quot;&#10;        assert self.frozen_popup.get_progress_points()==(expected_current_point, expected_required_point), f&quot;Progress points did not update correctly: {self.frozen_popup.get_progress_points()} != ({expected_current_point}, {expected_required_point})&quot;&#10;        assert self.frozen_popup.level_category_text== expected_rank_category, f&quot;Rank category did not update to {expected_rank_category}&quot;&#10;        assert int(self.frozen_popup.level_number_text)== expected_level_number, f&quot;Level number did not update to {expected_level_number}&quot;&#10;        assert int(self.frozen_popup.upgrade_price_text.replace(&quot;,&quot;,&quot;&quot;))== expected_upgrade_price, f&quot;Upgrade price did not update to {expected_upgrade_price}&quot;&#10;        actual_stats = [&#10;            passive.passive_stat_text.rstrip(&quot;%&quot;)&#10;            for passive in self.frozen_popup.passives&#10;        ]&#10;        actual_stats = [float(stat) for stat in actual_stats]&#10;        assert actual_stats == expected_passive_stats, f&quot;Passive stats did not update correctly: {actual_stats} != {expected_passive_stats}&quot;&#10;        self.test_deactivate_upgrade_btn()&#10;        logger.info(f&quot;Upgrade button activated successfully. Level: {expected_level}, Current Point: {expected_current_point}, Required Point: {expected_required_point}, Upgrade Price: {expected_upgrade_price}&quot;)&#10;&#10;    @pytest.mark.order(10)&#10;    def test_home_notice(self):&#10;        logger=get_logger()&#10;        if not self.home_notice:&#10;            logger.info(&quot;No home notice to check.&quot;)&#10;            return&#10;        assert self.home_notice.exists(), &quot;Home notice not found&quot;&#10;        group_notice=[&#10;            weapon_point.notice&#10;            for weapon_point in self.frozen_popup.weapon_points]&#10;        assert any(notice is not None for notice in group_notice), &quot;At least one notice should be visible&quot;&#10;        logger.info(&quot;Home notice and weapon point notices are present correctly.&quot;)&#10;    @pytest.mark.order(11)&#10;    def test_click_weapon_points(self):&#10;        logger=get_logger()&#10;        popup_get_point= None&#10;        for i, weapon_point in enumerate(self.frozen_popup.weapon_points):&#10;            logger.info(f&quot;Clicking on weapon point {i+1}: {weapon_point.name}&quot;)&#10;            weapon_point.root.click(sleep_interval=1)&#10;            logger.info(f&quot;Popup Military Get Point opened for {weapon_point.name}&quot;)&#10;            popup_get_point = PopupMilitaryGetPoint(self.poco,weapon_point._name)&#10;            with self.poco.freeze() as fp:&#10;                frozen_popup_get_point = PopupMilitaryGetPoint(fp,weapon_point._name)&#10;            assert frozen_popup_get_point.root.exists(), f&quot;Popup Military Get Point for {weapon_point.name} did not open&quot;&#10;            expected_weapon_point=self.verify_PopupMilitaryGetPoint(weapon_point._name, frozen_popup_get_point)&#10;            logger.info(f&quot;Expected weapon point for {weapon_point._name}: {expected_weapon_point}&quot;)&#10;            frozen_popup_get_point.btn_back.click(sleep_interval=1)&#10;            actual_weapon_point=[int(wp.accumulated_point) for wp in self.popup.weapon_points ]&#10;            logger.info(f&quot;Actual weapon point after closing popup: {actual_weapon_point}&quot;)&#10;            assert actual_weapon_point == expected_weapon_point, f&quot;Weapon point for {weapon_point._name} did not update correctly: {actual_weapon_point} != {expected_weapon_point}&quot;&#10;    def verify_PopupMilitaryGetPoint(self, name:str, popup_get_point:PopupMilitaryGetPoint)-&gt;list[int]:&#10;        &quot;&quot;&quot;Helper method to test popup get point functionality&#10;            Args:&#10;                name: The weapon point name (Air, Drone, Wing, Pilot, Engine)&#10;                popup_get_point: Instance of PopupMilitaryGetPoint created in test_click_weapon_points&#10;            Returns:&#10;                list[int]: List of accumulated points for each weapon&#10;        &quot;&quot;&quot;&#10;        logger=get_logger()&#10;        list_point=[(point._name,int(point.accumulated_point)) for point in popup_get_point.weapon_points ]&#10;        logger.info(f&quot;Popup Military Get Point {name} opened&quot;)&#10;        assert popup_get_point.middle_panel.exists(), &quot;Middle panel not found&quot;&#10;        title= &quot;Aircraft&quot; if name ==&quot;Air&quot; else name&#10;        assert popup_get_point.title== title, f&quot;Title text mismatch: {popup_get_point.title} != {title}&quot;&#10;        assert popup_get_point.generator.exists(), f&quot;Generator {name} not found&quot;&#10;        assert len(popup_get_point.items) == len_of_weapon[title], f&quot;Expected {len_of_weapon[title]} items, found {len(popup_get_point.items)}&quot;&#10;        def check_item(item):&#10;            logger.info(f&quot;Item {item.root} checking&quot;)&#10;            assert item.root.exists(), f&quot;Item {item.root} not found&quot;&#10;&#10;            if name == &quot;Pilot&quot;:&#10;                assert name.lower() in item.portrait.lower(), f&quot;Item icon for {name} does not contain expected sprite&quot;&#10;                assert item.flag != &quot;&quot;, f&quot;Flag for {item.root.name} should not be empty&quot;&#10;                assert any(r in item.rarity_frame for r in [&quot;R&quot;, &quot;SR&quot;, &quot;SSR&quot;]), \&#10;                    f&quot;Rarity frame for {item.root.name} should contain R, SR, or SSR, found {item.rarity_frame}&quot;&#10;            else:&#10;                icon = name.lower() if name.lower() != &quot;drone&quot; else &quot;wingman&quot;&#10;                assert icon in item.item_icon.lower(), f&quot;Item icon for {name} does not contain expected sprite&quot;&#10;&#10;            if title in [&quot;Aircraft&quot;, &quot;Drone&quot;, &quot;Wing&quot;]:&#10;                assert int(&#10;                    item.star_text) &gt;= 2, f&quot;Star text for {item.root.name} should be at least 2, found {item.star_text}&quot;&#10;            elif title == &quot;Pilot&quot;:&#10;                assert int(&#10;                    item.star_text) &gt;= 3, f&quot;Star text for {item.root.name} should be at least 3, found {item.star_text}&quot;&#10;            elif title == &quot;Engine&quot;:&#10;                assert int(&#10;                    item.star_text) &gt;= 1, f&quot;Star text for {item.root.name} should be at least 1, found {item.star_text}&quot;&#10;            else:&#10;                raise ValueError(f&quot;Unknown weapon type: {title}&quot;)&#10;&#10;            assert item.star_icon.exists(), f&quot;Star icon for {item.root.name} not found&quot;&#10;&#10;            if item.cover_BG: # locked item&#10;                assert item.lock_icon.exists(), f&quot;Lock icon for {item.root.name} not found&quot;&#10;                assert item.point_text is None, f&quot;Point text for {item.root.name} should be None when locked&quot;&#10;                assert item.claimed_icon is None, f&quot;Claimed icon for {item.root.name} should be None when locked&quot;&#10;            elif item.claimed_icon: # claimed item&#10;                assert item.point_text is None, f&quot;Point text for {item.root.name} should be None when claimed&quot;&#10;                assert item.lock_icon is None, f&quot;Lock icon for {item.root.name} should be None when claimed&quot;&#10;            elif item.point_text: # unclaimed item&#10;                assert int(&#10;                    item.point_text) &gt;= 1, f&quot;Point text for {item.root.name} should be at least 1, found {item.point_text}&quot;&#10;                assert item.lock_icon is None, f&quot;Lock icon for {item.root.name} should be None when point text is present&quot;&#10;                assert item.claimed_icon is None, f&quot;Claimed icon for {item.root.name} should be None when point text is present&quot;&#10;            logger.info(f&quot;Item {item.root} done checking&quot;)&#10;        def claim_point(item):&#10;            point=int(item.point_text)&#10;            item.root.click(sleep_interval=4)&#10;            # Refreeze to get fresh state&#10;            with self.poco.freeze() as fp:&#10;                refreshed_popup = PopupMilitaryGetPoint(fp)&#10;            fresh_item = next((i for i in refreshed_popup.items if str(i.root) == str(item.root)), None)&#10;            assert fresh_item.point_text is None, f&quot;Point text for {item.root.name} should be None after claiming&quot;&#10;            item.root.click()&#10;            check_noti(self.poco,&quot;You have already claimed the reward&quot;)&#10;            return point&#10;        for item in popup_get_point.items:&#10;            check_item(item)&#10;            if item.point_text: # if item has point text to be claimed&#10;                logger.info(f&quot;Claiming point for item {item.root}&quot;)&#10;                initial_point=next(point.accumulated_point for point in popup_get_point.weapon_points if point._name == name)&#10;                logger.info(f&quot;Initial accumulated point for {name}: {initial_point}&quot;)&#10;                increased_point=claim_point(item)&#10;                with self.poco.freeze() as fp: # refreeze to get fresh state&#10;                    popup_get_point = PopupMilitaryGetPoint(fp, name)&#10;                logger.info(f&quot;Increased point for {name}: {increased_point}&quot;)&#10;                sleep(1)&#10;                updated_point = next(point.accumulated_point for point in popup_get_point.weapon_points if point._name == name)&#10;                logger.info(f&quot;Updated accumulated point for {name}: {updated_point}&quot;)&#10;                assert int(updated_point) == int(initial_point) + increased_point, \&#10;                    f&quot;Accumulated point for {name} did not update correctly: {updated_point} != {initial_point} + {increased_point}&quot;&#10;                list_point = [(point[0], point[1] + (increased_point if point[0] == name else 0)) for point in list_point]&#10;                logger.info(f&quot;List of points after claiming: {list_point}&quot;)&#10;        return [int(point[1]) for point in list_point]&#10;&#10;    @pytest.mark.order(12)&#10;    def test_persistence_after_reopening(self):&#10;        logger = get_logger()&#10;        logger.info(&quot;Capturing initial state before closing popup&quot;)&#10;&#10;        # Capture initial state&#10;        initial_state = {&#10;            'level_number': self.popup.level_number_text,&#10;            'level_category': self.popup.level_category_text,&#10;            'progress_text': self.popup.progress_text,&#10;            'upgrade_price': self.popup.upgrade_price_text,&#10;            'passive_stats': [passive.passive_stat_text for passive in self.popup.passives],&#10;            'weapon_points': [point.accumulated_point for point in self.popup.weapon_points]&#10;        }&#10;&#10;        logger.info(f&quot;Initial state: {initial_state}&quot;)&#10;&#10;        # Close popup&#10;        logger.info(&quot;Closing PopupMilitary&quot;)&#10;        self.popup.btn_back.click(sleep_interval=1)&#10;        assert not self.popup.root.exists(), &quot;Popup did not close properly&quot;&#10;&#10;        # Reopen popup&#10;        logger.info(&quot;Reopening PopupMilitary&quot;)&#10;        military_home_icon = self.poco(&quot;SubFeatureTopLayer&quot;).offspring(&quot;Military_Home&quot;)&#10;        assert military_home_icon.exists(), &quot;Military home icon not found&quot;&#10;        military_home_icon.click(sleep_interval=1)&#10;&#10;        # Wait for popup to fully load&#10;        time.sleep(1)&#10;&#10;        # Create new popup instance&#10;        self.popup = PopupMilitary(self.poco)&#10;        assert self.popup.root.exists(), &quot;Military popup did not reopen&quot;&#10;&#10;        # Capture new state&#10;        reopened_state = {&#10;            'level_number': self.popup.level_number_text,&#10;            'level_category': self.popup.level_category_text,&#10;            'progress_text': self.popup.progress_text,&#10;            'upgrade_price': self.popup.upgrade_price_text,&#10;            'passive_stats': [passive.passive_stat_text for passive in self.popup.passives],&#10;            'weapon_points': [point.accumulated_point for point in self.popup.weapon_points]&#10;        }&#10;&#10;        logger.info(f&quot;Reopened state: {reopened_state}&quot;)&#10;&#10;        # Compare states&#10;        assert initial_state['level_number'] == reopened_state['level_number'], \&#10;            f&quot;Level number changed: {initial_state['level_number']} -&gt; {reopened_state['level_number']}&quot;&#10;&#10;        assert initial_state['level_category'] == reopened_state['level_category'], \&#10;            f&quot;Level category changed: {initial_state['level_category']} -&gt; {reopened_state['level_category']}&quot;&#10;&#10;        assert initial_state['progress_text'] == reopened_state['progress_text'], \&#10;            f&quot;Progress text changed: {initial_state['progress_text']} -&gt; {reopened_state['progress_text']}&quot;&#10;&#10;        assert initial_state['upgrade_price'] == reopened_state['upgrade_price'], \&#10;            f&quot;Upgrade price changed: {initial_state['upgrade_price']} -&gt; {reopened_state['upgrade_price']}&quot;&#10;&#10;        for i, (initial_stat, reopened_stat) in enumerate(&#10;                zip(initial_state['passive_stats'], reopened_state['passive_stats'])):&#10;            assert initial_stat == reopened_stat, \&#10;                f&quot;Passive stat {i} changed: {initial_stat} -&gt; {reopened_stat}&quot;&#10;&#10;        for i, (initial_point, reopened_point) in enumerate(&#10;                zip(initial_state['weapon_points'], reopened_state['weapon_points'])):&#10;            assert initial_point == reopened_point, \&#10;                f&quot;Weapon point {i} accumulated point changed: {initial_point} -&gt; {reopened_point}&quot;&#10;&#10;        logger.info(&quot;All elements persisted correctly after reopening the popup&quot;)" />
              <option name="updatedContent" value="import concurrent&#10;import time&#10;import pytest&#10;from Hierarchy.PopupMilitary import *&#10;from utils.device_setup import PocoManager&#10;from airtest.core.api import *&#10;from logger_config import get_logger&#10;from utils.helper_functions import check_noti&#10;from utils.get_resource_amount import get_single_resource_amount&#10;from concurrent.futures import ThreadPoolExecutor&#10;from functools import partial&#10;import pdb&#10;len_of_weapon={&#10;    &quot;Aircraft&quot;: 24,&#10;    &quot;Drone&quot;: 24,&#10;    &quot;Wing&quot;:24,&#10;    &quot;Pilot&quot;: 20,&#10;    &quot;Engine&quot;:18&#10;}&#10;&#10;@pytest.fixture(params=[&quot;Air&quot;, &quot;Drone&quot;, &quot;Wing&quot;, &quot;Pilot&quot;, &quot;Engine&quot;])&#10;def name(request) -&gt; Literal[&quot;Air&quot;, &quot;Drone&quot;, &quot;Wing&quot;, &quot;Pilot&quot;, &quot;Engine&quot;]:&#10;    &quot;&quot;&quot;Fixture that provides the name parameter for testing different military point types&quot;&quot;&quot;&#10;    return request.param&#10;@pytest.fixture(scope=&quot;class&quot;)&#10;def military_popup(poco):&#10;    try:&#10;        popup = poco(&quot;PopupMilitaryCareer(Clone)&quot;) if poco(&quot;PopupMilitaryCareer(Clone)&quot;).exists() else None&#10;        return popup&#10;    except Exception as e:&#10;        logger = get_logger()&#10;        logger.warning(f&quot;Failed to access PopupMilitary due to connection error: {e}&quot;)&#10;        return None&#10;&#10;@pytest.fixture(scope=&quot;class&quot;)&#10;def military_back_button(poco):&#10;    try:&#10;        button = poco(&quot;PopupMilitaryCareer(Clone)&quot;).offspring(&quot;B_Back (1)&quot;)&#10;        return button if button.exists() else None&#10;    except Exception as e:&#10;        logger = get_logger()&#10;        logger.warning(f&quot;Failed to access PopupMilitary back button due to connection error: {e}&quot;)&#10;        return None&#10;@pytest.mark.use_to_home(before=True, after=True, logger_name=&quot;PopupMilitary&quot;, back_button=&quot;military_back_button&quot;)&#10;class TestPopupMilitary:&#10;    popup= None&#10;    weapon_point_notices = []&#10;    @pytest.fixture(scope=&quot;function&quot;, autouse=True)&#10;    def setup(cls, poco):&#10;        logger = get_logger(&quot;setup method&quot;)&#10;        logger.info(&quot;Setting up PopupMilitary test environment...&quot;)&#10;        cls.poco = poco&#10;        cls.home_notice = poco(&quot;SubFeatureTopLayer&quot;).offspring(&quot;sNotice&quot;) if poco(&quot;SubFeatureTopLayer&quot;).offspring(&#10;            &quot;sNotice&quot;).exists() else None&#10;        military_home_icon = cls.poco(&quot;SubFeatureTopLayer&quot;).offspring(&quot;Military_Home&quot;)&#10;        assert military_home_icon.exists(), &quot;Military home icon not found&quot;&#10;        military_home_icon.click(sleep_interval=1)&#10;        cls.popup = PopupMilitary(cls.poco)&#10;        with poco.freeze() as fp:&#10;            cls.frozen_popup = PopupMilitary(fp)&#10;        print(f&quot;PopupMilitary instance created: {cls.popup}&quot;)&#10;        print(f&quot;Frozen PopupMilitary instance created: {cls.frozen_popup}&quot;)&#10;        assert cls.popup.root.exists(), &quot;Military popup did not open&quot;&#10;        logger.info(&quot;PopupMilitary test environment setup complete.&quot;)&#10;&#10;    def test_concurrent_exists(self,poco):&#10;        import threading&#10;        import time&#10;        results = {}&#10;        with poco.freeze() as fp:&#10;            freeze_popup = PopupMilitary(fp)&#10;&#10;        def check_back_button():&#10;            nodes = {&#10;                &quot;frozen_btn_back&quot;: freeze_popup.btn_back,&#10;                &quot;frozen_top_panel&quot;: freeze_popup.top_panel,&#10;                &quot;frozen_upgrade_btn&quot;: freeze_popup.upgrade_btn,&#10;                # &quot;btn_back&quot;: self.popup.btn_back,&#10;                # &quot;top_panel&quot;: self.popup.top_panel,&#10;            }&#10;            for k, n in nodes.items():&#10;                try:&#10;                    # presence/visibility from snapshot&#10;                    results[k] = n.exists()  # or n.exists()&#10;                    print(f&quot;Node {k} visibility: {results[k]}&quot;)&#10;                except Exception as e:&#10;                    results[k] = str(e)&#10;                    print(f&quot;Error accessing node {k}: {e}&quot;)&#10;        def check_top_panel():&#10;            nodes = {&#10;                &quot;frozen_rank_badge&quot;: freeze_popup.rank_badge,&#10;                &quot;frozen_upgrade_btn&quot;: freeze_popup.upgrade_btn,&#10;                # &quot;rank_badge&quot;: self.popup.rank_badge,&#10;                # &quot;upgrade_btn&quot;: self.popup.upgrade_btn,&#10;            }&#10;            for k, n in nodes.items():&#10;                try:&#10;                    # presence/visibility from snapshot&#10;                    results[k] = n.exists()  # or n.exists()&#10;                    print(f&quot;Node {k} visibility: {results[k]}&quot;)&#10;                except:&#10;                    results[k] = &quot;error&quot;&#10;                    print(f&quot;Error accessing node {k}&quot;)&#10;        t1 = threading.Thread(target=check_back_button)&#10;        t2 = threading.Thread(target=check_top_panel)&#10;&#10;        start_time = time.time()&#10;        t1.start()&#10;        t2.start()&#10;        t1.join()&#10;        t2.join()&#10;        total = time.time() - start_time&#10;&#10;        print(f&quot;Total time: {total:.3f}s&quot;)&#10;        # print(f&quot;btn_back took: {results['btn_back']}&quot;)&#10;        # print(f&quot;top_panel took: {results['top_panel']}&quot;)&#10;        for key, value in results.items(): print(f&quot;{key}: {value}&quot;)&#10;&#10;    def test_frozen_UI(self,poco):&#10;        logger=get_logger()&#10;        level=self.frozen_popup.get_actual_level()&#10;        print(&quot;::::FROZEN Level:&quot;,level)&#10;        for i, weapon_point in enumerate(self.frozen_popup.weapon_points):&#10;            logger.info(f&quot;Clicking on weapon point {i + 1}: {weapon_point.name}&quot;)&#10;            weapon_point.root.click(sleep_interval=1)&#10;            logger.info(f&quot;Popup Military Get Point opened for {weapon_point.name}&quot;)&#10;            popup_get_point = PopupMilitaryGetPoint(self.poco, weapon_point._name)&#10;            with self.poco.freeze() as fp:&#10;                frozen_popup_get_point = PopupMilitaryGetPoint(fp, weapon_point._name)&#10;            for item in frozen_popup_get_point.items:&#10;                print(&quot;::::FROZEN Item:&quot;, item.root)&#10;                # Scroll to item if needed (using live popup instance)&#10;                popup_get_point.scroll_to_item(item)&#10;                item.root.click(sleep_interval=2)&#10;&#10;    def test_frozen_element_presence(self,poco):&#10;        logger=get_logger()&#10;        with poco.freeze() as fp:&#10;            freeze_popup = PopupMilitary(fp)&#10;        assert freeze_popup.btn_back.exists(), &quot;Back button not found&quot;&#10;        assert freeze_popup.top_panel.exists(), &quot;Top panel not found&quot;&#10;        assert freeze_popup.title.strip() == &quot;Military Career&quot;, &quot;Title text mismatch&quot;&#10;        assert freeze_popup.rank_badge.exists(), &quot;Rank badge not found&quot;&#10;        assert freeze_popup.info_btn.exists(), &quot;Info button not found&quot;&#10;        assert freeze_popup.mid_panel.exists(), &quot;Mid panel not found&quot;&#10;        assert freeze_popup.mid_title.strip() == &quot;All squads get&quot;, &quot;Mid title text mismatch&quot;&#10;        assert len(freeze_popup.passives) == 6, &quot;Expected 6 passives, found {}&quot;.format(len(freeze_popup.passives))&#10;        for i, passive in enumerate(freeze_popup.passives):&#10;            assert passive.root.exists(), f&quot;Passive {i} not found&quot;&#10;            assert passive.sprite.exists(), f&quot;Passive {i} sprite not found&quot;&#10;            assert passive.passive_stat_text != &quot;&quot;, f&quot;Passive {i} stat text is empty&quot;&#10;            assert passive.passive_stat_text.endswith(&quot;%&quot;), f&quot;Passive {i} stat text does not end with '%': {passive.passive_stat_text}&quot;&#10;        assert freeze_popup.bot_panel.exists(), &quot;Bottom panel not found&quot;&#10;        assert freeze_popup.progress_fill.exists(), &quot;Process fill not found&quot;&#10;        assert freeze_popup.progress_info_btn.exists(), &quot;Process info button not found&quot;&#10;        assert freeze_popup.upgrade_btn.exists(), &quot;Upgrade button not found&quot;&#10;        assert len(freeze_popup.weapon_points) == 5, &quot;Expected 5 weapon points, found {}&quot;.format(len(freeze_popup.weapon_points))&#10;        for i, weapon_point in enumerate(freeze_popup.weapon_points):&#10;            assert weapon_point.root.exists(), f&quot;Weapon point {i} not found&quot;&#10;            assert weapon_point.icon.exists(), f&quot;Weapon point {i} icon not found&quot;&#10;            assert weapon_point.name not in [&quot;&quot;, None], f&quot;Weapon point {i} name is empty or None&quot;&#10;            assert int(weapon_point.accumulated_point) &gt;=0, f&quot;Weapon point {i} accumulated point is empty&quot;&#10;            if weapon_point.notice:&#10;                self.weapon_point_notices.append(True)&#10;            else:&#10;                self.weapon_point_notices.append(False)&#10;        assert freeze_popup.level_number_text.strip() != &quot;&quot;, &quot;Level number text is empty&quot;&#10;        assert freeze_popup.level_category_text.strip() != &quot;&quot;, &quot;Level category text is empty&quot;&#10;        assert freeze_popup.progress_text.strip() != &quot;&quot;, &quot;Process text is empty&quot;&#10;        assert freeze_popup.upgrade_price_text.strip() != &quot;&quot;, &quot;Upgrade price text is empty&quot;&#10;        logger.info(&quot;All elements are present and verified successfully.&quot;)&#10;&#10;    @pytest.mark.order(1)&#10;    def test_element_presence(self):&#10;        logger=get_logger()&#10;        assert self.frozen_popup.btn_back.exists(), &quot;Back button not found&quot;&#10;        assert self.frozen_popup.top_panel.exists(), &quot;Top panel not found&quot;&#10;        assert self.frozen_popup.title.strip() == &quot;Military Career&quot;, &quot;Title text mismatch&quot;&#10;        assert self.frozen_popup.rank_badge.exists(), &quot;Rank badge not found&quot;&#10;        assert self.frozen_popup.info_btn.exists(), &quot;Info button not found&quot;&#10;        assert self.frozen_popup.mid_panel.exists(), &quot;Mid panel not found&quot;&#10;        assert self.frozen_popup.mid_title.strip() == &quot;All squads get&quot;, &quot;Mid title text mismatch&quot;&#10;        assert len(self.frozen_popup.passives) == 6, &quot;Expected 6 passives, found {}&quot;.format(len(self.frozen_popup.passives))&#10;        for i, passive in enumerate(self.frozen_popup.passives):&#10;            assert passive.root.exists(), f&quot;Passive {i} not found&quot;&#10;            assert passive.sprite.exists(), f&quot;Passive {i} sprite not found&quot;&#10;            assert passive.passive_stat_text != &quot;&quot;, f&quot;Passive {i} stat text is empty&quot;&#10;            assert passive.passive_stat_text.endswith(&quot;%&quot;), f&quot;Passive {i} stat text does not end with '%': {passive.passive_stat_text}&quot;&#10;        assert self.frozen_popup.bot_panel.exists(), &quot;Bottom panel not found&quot;&#10;        assert self.frozen_popup.progress_fill.exists(), &quot;Process fill not found&quot;&#10;        assert self.frozen_popup.progress_info_btn.exists(), &quot;Process info button not found&quot;&#10;        assert self.frozen_popup.upgrade_btn.exists(), &quot;Upgrade button not found&quot;&#10;        assert len(self.frozen_popup.weapon_points) == 5, &quot;Expected 5 weapon points, found {}&quot;.format(len(self.frozen_popup.weapon_points))&#10;        for i, weapon_point in enumerate(self.frozen_popup.weapon_points):&#10;            assert weapon_point.root.exists(), f&quot;Weapon point {i} not found&quot;&#10;            assert weapon_point.icon.exists(), f&quot;Weapon point {i} icon not found&quot;&#10;            assert weapon_point.name not in [&quot;&quot;, None], f&quot;Weapon point {i} name is empty or None&quot;&#10;            assert int(weapon_point.accumulated_point) &gt;=0, f&quot;Weapon point {i} accumulated point is empty&quot;&#10;            if weapon_point.notice:&#10;                self.weapon_point_notices.append(True)&#10;            else:&#10;                self.weapon_point_notices.append(False)&#10;        assert self.frozen_popup.level_number_text.strip() != &quot;&quot;, &quot;Level number text is empty&quot;&#10;        assert self.frozen_popup.level_category_text.strip() != &quot;&quot;, &quot;Level category text is empty&quot;&#10;        assert self.frozen_popup.progress_text.strip() != &quot;&quot;, &quot;Process text is empty&quot;&#10;        assert self.frozen_popup.upgrade_price_text.strip() != &quot;&quot;, &quot;Upgrade price text is empty&quot;&#10;        logger.info(&quot;All elements are present and verified successfully.&quot;)&#10;    @pytest.mark.order(2)&#10;    def test_valid_rank_category(self):&#10;        logger=get_logger()&#10;        actual_rank=self.frozen_popup.level_category_text&#10;        assert actual_rank in rank_category, f&quot;Invalid rank category: {actual_rank}&quot;&#10;        logger.info(f&quot;rank category '{actual_rank}' is valid.&quot;)&#10;    @pytest.mark.order(3)&#10;    def test_click_info_button(self):&#10;        logger=get_logger()&#10;        self.frozen_popup.info_btn.click(sleep_interval=1)&#10;        popup_info= PopupMilitaryCareerInfo(self.poco)&#10;        assert popup_info.root.exists(), &quot;Popup Military Career Info did not open&quot;&#10;        popup_info.btn_back.click(sleep_interval=1)&#10;        assert not popup_info.root.exists(), &quot;Popup Military Career Info did not close&quot;&#10;        logger.info(&quot;Info button functionality verified successfully.&quot;)&#10;    @pytest.mark.order(4)&#10;    def test_passive_sprite(self):&#10;        logger=get_logger()&#10;        actual_sprites=[&#10;            passive.sprite.attr(&quot;texture&quot;).strip()&#10;            for passive in self.frozen_popup.passives&#10;        ]&#10;        for i, actual_sprite in enumerate(actual_sprites):&#10;            assert actual_sprite == expected_passive_sprites[i], f&quot;Passive {i} sprite mismatch: {actual_sprite} != {expected_passive_sprites[i]}&quot;&#10;        logger.info(&quot;Passive sprite functionality verified successfully.&quot;)&#10;    @pytest.mark.order(5)&#10;    def test_passive_stat(self):&#10;        logger=get_logger()&#10;        actual_stats=[&#10;            passive.passive_stat_text.rstrip(&quot;%&quot;)&#10;            for passive in self.frozen_popup.passives&#10;        ]&#10;        actual_stats=[float(stat) for stat in actual_stats]&#10;        actual_lv=self.frozen_popup.get_actual_level()&#10;        expected_stats= self.frozen_popup.get_expected_stats_by_lv(actual_lv)&#10;        assert actual_stats == expected_stats, f&quot;Stats mismatch - Actual: {actual_stats}, Expected: {expected_stats}&quot;&#10;        logger.info(&quot;Passive stats  verified successfully.&quot;)&#10;    @pytest.mark.order(6)&#10;    def test_click_progress_info_button(self):&#10;        logger=get_logger()&#10;        self.frozen_popup.progress_info_btn.click(sleep_interval=1.5)&#10;        panel=self.poco(&quot;PanelTooltipInfo&quot;).offspring(&quot;lDes&quot;)&#10;        panel_text=panel.get_text().strip()&#10;        assert panel_text==&quot;Career Point&quot;, &quot;Progress info button did not show correct text&quot;&#10;        self.frozen_popup.progress_info_btn.click(sleep_interval=1.5)&#10;        panel=self.poco(&quot;PanelTooltipInfo&quot;).offspring(&quot;lDes&quot;)&#10;        assert not panel.exists(), &quot;Panel did not close after clicking again&quot;&#10;    @pytest.mark.order(7)&#10;    def test_valid_progress_point_and_price(self):&#10;        logger=get_logger()&#10;        actual_current_point,actual_required_point= self.frozen_popup.get_progress_points()&#10;        assert actual_current_point &gt;= 0, f&quot;Current point is negative: {actual_current_point}&quot;&#10;        expected_required_point= PopupMilitary.get_expected_required_point(self.frozen_popup.get_actual_level()+1)&#10;        assert actual_required_point == expected_required_point, f&quot;Required point mismatch: {actual_required_point} != {expected_required_point}&quot;&#10;        actual_price=int(self.frozen_popup.upgrade_price_text.replace(&quot;,&quot;,&quot;&quot;))&#10;        assert actual_price==PopupMilitary.get_expected_upgrade_price(self.frozen_popup.get_actual_level()+1), f&quot;Upgrade price mismatch: {actual_price} != {PopupMilitary.get_expected_upgrade_price(self.frozen_popup.get_actual_level()+1)}&quot;&#10;        logger.info(f&quot;Progress points and upgrade price verified successfully: Current Point: {actual_current_point}, Required Point: {actual_required_point}, Upgrade Price: {actual_price}&quot;)&#10;&#10;    @pytest.mark.order(8)&#10;    def test_deactivate_upgrade_btn(self):&#10;        logger=get_logger()&#10;        current_point,required_point= self.frozen_popup.get_progress_points()&#10;        upgrade_price=self.frozen_popup.upgrade_price_text&#10;        initial_values = (current_point, required_point, upgrade_price)&#10;        if current_point&gt;=required_point:&#10;            logger.info(&quot;active upgrade button&quot;)&#10;            return&#10;        assert not self.frozen_popup.upgrade_btn_notice, &quot;Upgrade button notice should not be active&quot;&#10;        assert self.frozen_popup.upgrade_btn_sprite==&quot;UI5_Bottom_btn_9sl_Grey&quot;, f&quot;Upgrade button sprite should be greyed out, found {self.popup.upgrade_btn_sprite}&quot;&#10;        self.frozen_popup.upgrade_btn.click()&#10;        check_noti(self.poco,&quot;Not enough currency&quot;)&#10;        #verify state after click&#10;        assert not self.popup.upgrade_btn_notice, &quot;Upgrade button notice should not be active&quot;&#10;        assert self.popup.upgrade_btn_sprite == &quot;UI5_Bottom_btn_9sl_Grey&quot;, f&quot;Upgrade button sprite should be greyed out, found {self.popup.upgrade_btn_sprite}&quot;&#10;        refreshed_values = (&#10;            *self.popup.get_progress_points(),&#10;            self.popup.upgrade_price_text&#10;        )&#10;        assert initial_values == refreshed_values, (&#10;            f&quot;Upgrade button click should not change points or price, but got {refreshed_values}&quot;&#10;        )&#10;        print(f&quot;homenotice:{self.home_notice}&quot;)&#10;        logger.info(&quot;Upgrade button deactivated successfully when points are insufficient.&quot;)&#10;    @pytest.mark.order(9)&#10;    def test_active_upgrade_btn(self):&#10;        logger=get_logger()&#10;        current_point,required_point= self.frozen_popup.get_progress_points()&#10;        upgrade_price=int(self.frozen_popup.upgrade_price_text.replace(&quot;,&quot;,&quot;&quot;))&#10;        initial_values = (self.frozen_popup.get_actual_level(),current_point, required_point, upgrade_price)&#10;        if current_point&lt;required_point:&#10;            logger.info(&quot;deactive upgrade button&quot;)&#10;            return&#10;        if upgrade_price&gt;get_single_resource_amount(self.poco, &quot;gold&quot;):&#10;            self.frozen_popup.upgrade_btn.click()&#10;            popup_notice= self.poco(&quot;PopupNotice(Clone)&quot;) if self.poco(&quot;PopupNotice(Clone)&quot;).exists() else None&#10;            assert popup_notice, &quot;Popup Notice did not appear&quot;&#10;            popup_notice.offspring(&quot;bClose&quot;).click(sleep_interval=1)&#10;            popup_notice= self.poco(&quot;PopupNotice(Clone)&quot;) if self.poco(&quot;PopupNotice(Clone)&quot;).exists() else None&#10;            assert not popup_notice, &quot;Popup Notice did not close after clicking close button&quot;&#10;            self.poco.invoke(&quot;add_gold&quot;, amount=upgrade_price)&#10;            time.sleep(3)&#10;            assert upgrade_price&lt;get_single_resource_amount(self.poco, &quot;gold&quot;), f&quot;Upgrade price {upgrade_price} is greater than gem amount {get_single_resource_amount(self.poco, 'gem')}&quot;&#10;        assert self.popup.upgrade_btn_notice, &quot;Upgrade button notice should be active&quot;&#10;        assert self.popup.upgrade_btn_sprite==&quot;UI5_Bottom_btn_9sl_Blue&quot;, f&quot;Upgrade button sprite should be orange, found {self.popup.upgrade_btn_sprite}&quot;&#10;        self.frozen_popup.upgrade_btn.click(sleep_interval=7)&#10;        #verify state after click&#10;        expected_level= initial_values[0]+1&#10;        expected_current_point= initial_values[1]- initial_values[2]&#10;        expected_required_point = PopupMilitary.get_expected_required_point(expected_level + 1)&#10;        expected_rank_category=rank_category[expected_level//10]&#10;        expected_level_number= expected_level % 10&#10;        expected_upgrade_price= PopupMilitary.get_expected_upgrade_price(expected_level+1)&#10;        with self.poco.freeze() as fp:&#10;            self.frozen_popup = PopupMilitary(fp)&#10;        expected_passive_stats= self.frozen_popup.get_expected_stats_by_lv(expected_level)&#10;        assert self.frozen_popup.get_actual_level() == expected_level, f&quot;Level did not upgrade to {expected_level}&quot;&#10;        assert self.frozen_popup.get_progress_points()==(expected_current_point, expected_required_point), f&quot;Progress points did not update correctly: {self.frozen_popup.get_progress_points()} != ({expected_current_point}, {expected_required_point})&quot;&#10;        assert self.frozen_popup.level_category_text== expected_rank_category, f&quot;Rank category did not update to {expected_rank_category}&quot;&#10;        assert int(self.frozen_popup.level_number_text)== expected_level_number, f&quot;Level number did not update to {expected_level_number}&quot;&#10;        assert int(self.frozen_popup.upgrade_price_text.replace(&quot;,&quot;,&quot;&quot;))== expected_upgrade_price, f&quot;Upgrade price did not update to {expected_upgrade_price}&quot;&#10;        actual_stats = [&#10;            passive.passive_stat_text.rstrip(&quot;%&quot;)&#10;            for passive in self.frozen_popup.passives&#10;        ]&#10;        actual_stats = [float(stat) for stat in actual_stats]&#10;        assert actual_stats == expected_passive_stats, f&quot;Passive stats did not update correctly: {actual_stats} != {expected_passive_stats}&quot;&#10;        self.test_deactivate_upgrade_btn()&#10;        logger.info(f&quot;Upgrade button activated successfully. Level: {expected_level}, Current Point: {expected_current_point}, Required Point: {expected_required_point}, Upgrade Price: {expected_upgrade_price}&quot;)&#10;&#10;    @pytest.mark.order(10)&#10;    def test_home_notice(self):&#10;        logger=get_logger()&#10;        if not self.home_notice:&#10;            logger.info(&quot;No home notice to check.&quot;)&#10;            return&#10;        assert self.home_notice.exists(), &quot;Home notice not found&quot;&#10;        group_notice=[&#10;            weapon_point.notice&#10;            for weapon_point in self.frozen_popup.weapon_points]&#10;        assert any(notice is not None for notice in group_notice), &quot;At least one notice should be visible&quot;&#10;        logger.info(&quot;Home notice and weapon point notices are present correctly.&quot;)&#10;    @pytest.mark.order(11)&#10;    def test_click_weapon_points(self):&#10;        logger=get_logger()&#10;        popup_get_point= None&#10;        for i, weapon_point in enumerate(self.frozen_popup.weapon_points):&#10;            logger.info(f&quot;Clicking on weapon point {i+1}: {weapon_point.name}&quot;)&#10;            weapon_point.root.click(sleep_interval=1)&#10;            logger.info(f&quot;Popup Military Get Point opened for {weapon_point.name}&quot;)&#10;            popup_get_point = PopupMilitaryGetPoint(self.poco,weapon_point._name)&#10;            with self.poco.freeze() as fp:&#10;                frozen_popup_get_point = PopupMilitaryGetPoint(fp,weapon_point._name)&#10;            assert frozen_popup_get_point.root.exists(), f&quot;Popup Military Get Point for {weapon_point.name} did not open&quot;&#10;            expected_weapon_point=self.verify_PopupMilitaryGetPoint(weapon_point._name, frozen_popup_get_point)&#10;            logger.info(f&quot;Expected weapon point for {weapon_point._name}: {expected_weapon_point}&quot;)&#10;            frozen_popup_get_point.btn_back.click(sleep_interval=1)&#10;            actual_weapon_point=[int(wp.accumulated_point) for wp in self.popup.weapon_points ]&#10;            logger.info(f&quot;Actual weapon point after closing popup: {actual_weapon_point}&quot;)&#10;            assert actual_weapon_point == expected_weapon_point, f&quot;Weapon point for {weapon_point._name} did not update correctly: {actual_weapon_point} != {expected_weapon_point}&quot;&#10;    def verify_PopupMilitaryGetPoint(self, name:str, popup_get_point:PopupMilitaryGetPoint)-&gt;list[int]:&#10;        &quot;&quot;&quot;Helper method to test popup get point functionality&#10;            Args:&#10;                name: The weapon point name (Air, Drone, Wing, Pilot, Engine)&#10;                popup_get_point: Instance of PopupMilitaryGetPoint created in test_click_weapon_points&#10;            Returns:&#10;                list[int]: List of accumulated points for each weapon&#10;        &quot;&quot;&quot;&#10;        logger=get_logger()&#10;        list_point=[(point._name,int(point.accumulated_point)) for point in popup_get_point.weapon_points ]&#10;        logger.info(f&quot;Popup Military Get Point {name} opened&quot;)&#10;        assert popup_get_point.middle_panel.exists(), &quot;Middle panel not found&quot;&#10;        title= &quot;Aircraft&quot; if name ==&quot;Air&quot; else name&#10;        assert popup_get_point.title== title, f&quot;Title text mismatch: {popup_get_point.title} != {title}&quot;&#10;        assert popup_get_point.generator.exists(), f&quot;Generator {name} not found&quot;&#10;        assert len(popup_get_point.items) == len_of_weapon[title], f&quot;Expected {len_of_weapon[title]} items, found {len(popup_get_point.items)}&quot;&#10;        def check_item(item):&#10;            logger.info(f&quot;Item {item.root} checking&quot;)&#10;            assert item.root.exists(), f&quot;Item {item.root} not found&quot;&#10;&#10;            if name == &quot;Pilot&quot;:&#10;                assert name.lower() in item.portrait.lower(), f&quot;Item icon for {name} does not contain expected sprite&quot;&#10;                assert item.flag != &quot;&quot;, f&quot;Flag for {item.root.name} should not be empty&quot;&#10;                assert any(r in item.rarity_frame for r in [&quot;R&quot;, &quot;SR&quot;, &quot;SSR&quot;]), \&#10;                    f&quot;Rarity frame for {item.root.name} should contain R, SR, or SSR, found {item.rarity_frame}&quot;&#10;            else:&#10;                icon = name.lower() if name.lower() != &quot;drone&quot; else &quot;wingman&quot;&#10;                assert icon in item.item_icon.lower(), f&quot;Item icon for {name} does not contain expected sprite&quot;&#10;&#10;            if title in [&quot;Aircraft&quot;, &quot;Drone&quot;, &quot;Wing&quot;]:&#10;                assert int(&#10;                    item.star_text) &gt;= 2, f&quot;Star text for {item.root.name} should be at least 2, found {item.star_text}&quot;&#10;            elif title == &quot;Pilot&quot;:&#10;                assert int(&#10;                    item.star_text) &gt;= 3, f&quot;Star text for {item.root.name} should be at least 3, found {item.star_text}&quot;&#10;            elif title == &quot;Engine&quot;:&#10;                assert int(&#10;                    item.star_text) &gt;= 1, f&quot;Star text for {item.root.name} should be at least 1, found {item.star_text}&quot;&#10;            else:&#10;                raise ValueError(f&quot;Unknown weapon type: {title}&quot;)&#10;&#10;            assert item.star_icon.exists(), f&quot;Star icon for {item.root.name} not found&quot;&#10;&#10;            if item.cover_BG: # locked item&#10;                assert item.lock_icon.exists(), f&quot;Lock icon for {item.root.name} not found&quot;&#10;                assert item.point_text is None, f&quot;Point text for {item.root.name} should be None when locked&quot;&#10;                assert item.claimed_icon is None, f&quot;Claimed icon for {item.root.name} should be None when locked&quot;&#10;            elif item.claimed_icon: # claimed item&#10;                assert item.point_text is None, f&quot;Point text for {item.root.name} should be None when claimed&quot;&#10;                assert item.lock_icon is None, f&quot;Lock icon for {item.root.name} should be None when claimed&quot;&#10;            elif item.point_text: # unclaimed item&#10;                assert int(&#10;                    item.point_text) &gt;= 1, f&quot;Point text for {item.root.name} should be at least 1, found {item.point_text}&quot;&#10;                assert item.lock_icon is None, f&quot;Lock icon for {item.root.name} should be None when point text is present&quot;&#10;                assert item.claimed_icon is None, f&quot;Claimed icon for {item.root.name} should be None when point text is present&quot;&#10;            logger.info(f&quot;Item {item.root} done checking&quot;)&#10;        def claim_point(item):&#10;            point=int(item.point_text)&#10;            item.root.click(sleep_interval=4)&#10;            # Refreeze to get fresh state&#10;            with self.poco.freeze() as fp:&#10;                refreshed_popup = PopupMilitaryGetPoint(fp)&#10;            fresh_item = next((i for i in refreshed_popup.items if str(i.root) == str(item.root)), None)&#10;            assert fresh_item.point_text is None, f&quot;Point text for {item.root.name} should be None after claiming&quot;&#10;            item.root.click()&#10;            check_noti(self.poco,&quot;You have already claimed the reward&quot;)&#10;            return point&#10;        for item in popup_get_point.items:&#10;            check_item(item)&#10;            if item.point_text: # if item has point text to be claimed&#10;                logger.info(f&quot;Claiming point for item {item.root}&quot;)&#10;                initial_point=next(point.accumulated_point for point in popup_get_point.weapon_points if point._name == name)&#10;                logger.info(f&quot;Initial accumulated point for {name}: {initial_point}&quot;)&#10;                increased_point=claim_point(item)&#10;                with self.poco.freeze() as fp: # refreeze to get fresh state&#10;                    popup_get_point = PopupMilitaryGetPoint(fp, name)&#10;                logger.info(f&quot;Increased point for {name}: {increased_point}&quot;)&#10;                sleep(1)&#10;                updated_point = next(point.accumulated_point for point in popup_get_point.weapon_points if point._name == name)&#10;                logger.info(f&quot;Updated accumulated point for {name}: {updated_point}&quot;)&#10;                assert int(updated_point) == int(initial_point) + increased_point, \&#10;                    f&quot;Accumulated point for {name} did not update correctly: {updated_point} != {initial_point} + {increased_point}&quot;&#10;                list_point = [(point[0], point[1] + (increased_point if point[0] == name else 0)) for point in list_point]&#10;                logger.info(f&quot;List of points after claiming: {list_point}&quot;)&#10;        return [int(point[1]) for point in list_point]&#10;&#10;    @pytest.mark.order(12)&#10;    def test_persistence_after_reopening(self):&#10;        logger = get_logger()&#10;        logger.info(&quot;Capturing initial state before closing popup&quot;)&#10;&#10;        # Capture initial state&#10;        initial_state = {&#10;            'level_number': self.popup.level_number_text,&#10;            'level_category': self.popup.level_category_text,&#10;            'progress_text': self.popup.progress_text,&#10;            'upgrade_price': self.popup.upgrade_price_text,&#10;            'passive_stats': [passive.passive_stat_text for passive in self.popup.passives],&#10;            'weapon_points': [point.accumulated_point for point in self.popup.weapon_points]&#10;        }&#10;&#10;        logger.info(f&quot;Initial state: {initial_state}&quot;)&#10;&#10;        # Close popup&#10;        logger.info(&quot;Closing PopupMilitary&quot;)&#10;        self.popup.btn_back.click(sleep_interval=1)&#10;        assert not self.popup.root.exists(), &quot;Popup did not close properly&quot;&#10;&#10;        # Reopen popup&#10;        logger.info(&quot;Reopening PopupMilitary&quot;)&#10;        military_home_icon = self.poco(&quot;SubFeatureTopLayer&quot;).offspring(&quot;Military_Home&quot;)&#10;        assert military_home_icon.exists(), &quot;Military home icon not found&quot;&#10;        military_home_icon.click(sleep_interval=1)&#10;&#10;        # Wait for popup to fully load&#10;        time.sleep(1)&#10;&#10;        # Create new popup instance&#10;        self.popup = PopupMilitary(self.poco)&#10;        assert self.popup.root.exists(), &quot;Military popup did not reopen&quot;&#10;&#10;        # Capture new state&#10;        reopened_state = {&#10;            'level_number': self.popup.level_number_text,&#10;            'level_category': self.popup.level_category_text,&#10;            'progress_text': self.popup.progress_text,&#10;            'upgrade_price': self.popup.upgrade_price_text,&#10;            'passive_stats': [passive.passive_stat_text for passive in self.popup.passives],&#10;            'weapon_points': [point.accumulated_point for point in self.popup.weapon_points]&#10;        }&#10;&#10;        logger.info(f&quot;Reopened state: {reopened_state}&quot;)&#10;&#10;        # Compare states&#10;        assert initial_state['level_number'] == reopened_state['level_number'], \&#10;            f&quot;Level number changed: {initial_state['level_number']} -&gt; {reopened_state['level_number']}&quot;&#10;&#10;        assert initial_state['level_category'] == reopened_state['level_category'], \&#10;            f&quot;Level category changed: {initial_state['level_category']} -&gt; {reopened_state['level_category']}&quot;&#10;&#10;        assert initial_state['progress_text'] == reopened_state['progress_text'], \&#10;            f&quot;Progress text changed: {initial_state['progress_text']} -&gt; {reopened_state['progress_text']}&quot;&#10;&#10;        assert initial_state['upgrade_price'] == reopened_state['upgrade_price'], \&#10;            f&quot;Upgrade price changed: {initial_state['upgrade_price']} -&gt; {reopened_state['upgrade_price']}&quot;&#10;&#10;        for i, (initial_stat, reopened_stat) in enumerate(&#10;                zip(initial_state['passive_stats'], reopened_state['passive_stats'])):&#10;            assert initial_stat == reopened_stat, \&#10;                f&quot;Passive stat {i} changed: {initial_stat} -&gt; {reopened_stat}&quot;&#10;&#10;        for i, (initial_point, reopened_point) in enumerate(&#10;                zip(initial_state['weapon_points'], reopened_state['weapon_points'])):&#10;            assert initial_point == reopened_point, \&#10;                f&quot;Weapon point {i} accumulated point changed: {initial_point} -&gt; {reopened_point}&quot;&#10;&#10;        logger.info(&quot;All elements persisted correctly after reopening the popup&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>